import { Component, OnInit } from '@angular/core'
import { Store } from '@ngrx/store'
import { MockData } from '../../../../shared/models/mock-data.model'
import { combineLatest, firstValueFrom, of } from 'rxjs'
import { FormControl, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms'
import {
  hasSelectedEntries,
  selectEntries,
  selectIsEntrySelected,
  selectNumberOfEntries,
  selectNumberOfSelectedEntries,
} from '../../+store/selectors/example-feature-1.selectors'
import {
  addDataEntryActions,
  addMissingToSelection,
  addSelection,
  loadMockDataEntriesActions,
  removeSelectedEntries,
  removeSelection,
  resetSelectedEntries,
} from '../../+store/actions/example-feature-1.actions'
import {
  selectChangeUserDataLoadingState,
  selectInitLoadingState,
} from '../../+store/selectors/example-feature-1-loading.selectors'
import { AsyncPipe, NgClass, NgIf } from '@angular/common'
import { MatCard, MatCardContent, MatCardHeader } from '@angular/material/card'
import { MatFormField, MatInput, MatLabel } from '@angular/material/input'
import {
  MatCell,
  MatCellDef,
  MatColumnDef,
  MatHeaderCell,
  MatHeaderCellDef,
  MatHeaderRow,
  MatHeaderRowDef,
  MatRow,
  MatRowDef,
  MatTable,
} from '@angular/material/table'
import { MatCheckbox } from '@angular/material/checkbox'
import { MatButton } from '@angular/material/button'
import { map } from 'rxjs/operators'
import { MatProgressSpinner } from '@angular/material/progress-spinner'

@Component({
  selector: 'app-my-customers',
  imports: [
    AsyncPipe,
    FormsModule,
    ReactiveFormsModule,
    MatCard,
    MatCardHeader,
    MatCardContent,
    MatFormField,
    MatInput,
    MatLabel,
    MatTable,
    MatColumnDef,
    MatHeaderCell,
    MatHeaderCellDef,
    MatCell,
    MatCellDef,
    MatHeaderRowDef,
    MatHeaderRow,
    MatRowDef,
    MatRow,
    MatCheckbox,
    MatButton,
    NgIf,
    MatProgressSpinner,
    NgClass,
  ],
  templateUrl: './my-customers.component.html',
  styleUrl: './my-customers.component.scss',
  standalone: true,
})
export class MyCustomersComponent implements OnInit {
  displayedColumns: string[] = ['select', 'ID', 'name', 'age', 'email']
  skeletonRows = Array.from({ length: 5 })
  
  constructor(private store: Store) {
  }
  
  protected entries: MockData[] = []
  protected initLoadingState$ = this.store.select(selectInitLoadingState)
  protected userDataLoadingState$ = this.store.select(selectChangeUserDataLoadingState)
  
  public newPersonFormGroup: FormGroup = new FormGroup({})
  
  ngOnInit(): void {
    this.store.dispatch(loadMockDataEntriesActions.loadMockDataEntries())
    this.newPersonFormGroup = this.initFormGroup()
    
    this.store.select(selectEntries).subscribe((entries: MockData[]) => {
      this.entries = entries
    })
  }
  
  /**
   * Just for testing purposes, in a real scenario this will be generated by the backend
   * @param length
   */
  public generateRandomHex(length: number): string {
    const characters: string = '0123456789abcdef'
    let result = ''
    
    for (let i = 0; i < length; i++) {
      const randomIndex = Math.floor(Math.random() * characters.length)
      result += characters.charAt(randomIndex)
    }
    
    return result
  }
  
  public addCustomer(): void {
    const newUser: MockData = this.initialiseNewUser()
    this.store.dispatch(
      addDataEntryActions.addDataEntry({ mockDataEntry: newUser }),
    )
    this.newPersonFormGroup.reset()
  }
  
  private initialiseNewUser() {
    const randomHexValue: string = this.generateRandomHex(24)
    const newUser: MockData = {
      id: randomHexValue,
      name: this.newPersonFormGroup.get('name')?.value,
      age: this.newPersonFormGroup.get('age')?.value,
      email: this.newPersonFormGroup.get('email')?.value,
    }
    
    return newUser
  }
  
  private initFormGroup() {
    return new FormGroup({
      id: new FormControl({ value: '', disabled: true }),
      name: new FormControl('', Validators.required),
      age: new FormControl('', Validators.required),
      email: new FormControl('', Validators.required),
    })
  }
  
  selectionToggle(entry: any, row: any) {
    const checked = entry.checked
    if (checked) {
      this.store.dispatch(addSelection({ entryId: row.id }))
    } else {
      this.store.dispatch(removeSelection({ entryId: row.id }))
    }
  }
  
  hasSelection() {
    return this.store.select(hasSelectedEntries)
  }
  
  removeCustomers() {
    this.store.dispatch(removeSelectedEntries())
    this.store.dispatch(resetSelectedEntries())
  }
  
  /** Whether the number of selected elements matches the total number of rows. */
  isAllSelected() {
    const numSelected = this.store.select(selectNumberOfSelectedEntries)
    const numRows = this.store.select(selectNumberOfEntries)
    return combineLatest([numSelected, numRows]).pipe(
      map(([source1, source2]) =>
        source1 !== 0 && source2 !== 0 && source1 === source2,
      ),
    )
  }
  
  /** Selects all rows if they are not all selected; otherwise clear selection. */
  async toggleAllRows() {
    const allSelected = await firstValueFrom(this.isAllSelected())
    this.store.dispatch(
      allSelected ? resetSelectedEntries() : addMissingToSelection(),
    )
  }
  
  isSelected(row: MockData) {
    if (!!row) {
      return this.store.select(selectIsEntrySelected(row.id))
    }
    return of(false)
  }
}
